#!/usr/bin/env python3
import os
import sys
import tempfile
import logging
import json
import zipfile
import click
import jinja2
import app
# Add current path to sys path for loading libraries
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

@click.command()
@click.option('-m', '--manifest', required=True, type=str,
    help="The file manifest as csv file; first row defines labels for each column")
@click.option('-s', '--suite', required=True, type=str,
    help="The suite file defining files to match and what stages to run")
@click.option('-d', '--dir', 'sourcedir', required=True, type=str,
    help="The source directory in which to find files defined by the suite and manifest")
@click.option('-w', '--workdir', type=str,
    help="A directory where to store temp files and results")
@click.option('-r', '--retry', type=str,
    help="Re-run failed tests specified in provided JSON file from previous run")
@click.option('-t', '--strict', is_flag=True,
    help="Exit code 0 only with no manifest entries skipped and no unassociated files")
@click.option('-p', '--dir-prefix', 'prefix', type=str,
    help="Run colophon from within this path prefix; will remove prefix from logs/reports")
@click.option('-v', '--verbose', is_flag=True,
    help="Provide details output while running")
@click.option('-q', '--quiet', is_flag=True,
    help="Suppress output while running")
def main(manifest, suite, sourcedir, workdir, retry, strict, prefix, verbose, quiet):
    """Colophon - File Quality Control Validator"""
    # Create output dir if not provided
    if workdir is not None:
        app.workdir = os.path.abspath(workdir)
        if len(os.listdir(app.workdir)) != 0:
            raise app.ColophonException(f"Work directory must be empty: {workdir}")
    else:
        app.workdir = tempfile.mkdtemp()

    # Configure logging
    fileHandler = logging.FileHandler(os.path.join(app.workdir, 'colophon.log'))
    stderrHandler = logging.StreamHandler()
    stderrHandler.setLevel(
        logging.DEBUG if verbose else (logging.ERROR if quiet else logging.INFO)
    )
    logging.basicConfig(
        format="%(asctime)s [%(levelname)s] %(message)s",
        encoding='utf-8',
        level=logging.DEBUG,
        handlers=[fileHandler, stderrHandler]
    )
    app.logger = logging.getLogger()

    # Path prefix to remove from paths
    app.prefix = prefix.rstrip('/') if prefix else ''
    # Manifest exists and is loadable
    app.manifest = app.Manifest(manifest)
    # Suite file exists and is loadable
    app.suite = app.Suite(suite)
    # Source dir exists and is readable
    app.sourcedir = app.Directory(sourcedir)

    # Populate results JSON with empty dict
    results_path = os.path.join(app.workdir, 'results.json')
    with open(results_path, 'w') as results_file:
        json.dump({}, results_file)
    app.globalctx['results_path'] = results_path

    # TODO Retry failures from previous run

    # Pass manifest through suite to filter out rows to ignore
    app.logger.debug("Applying suite filter to manifest...")
    for entry in app.manifest:
        entry.filtered = app.suite.filter(entry)
    app.logger.debug(
        f"Manifest rows: selected={app.manifest.count()}, "
        f"filtered={app.manifest.count(True)}"
    )

    # For each manifest row, match/associate files to that row
    for entry in app.manifest:
        app.logger.debug(f"Labeling files for manifest row: {app.suite.manifest_id(entry)}")
        matched, failed = app.suite.label_files(entry)
        app.logger.debug(f"Files-found={matched}, failed-labels={failed}")
        if failed:
            fmsg = (
                f"Manifest(id={app.suite.manifest_id(entry)}) encountered "
                f"{failed} failures while creating file labels."
            )
            entry.failures.append(fmsg)
            app.logger.warning(fmsg)

    # For each manifest row, run scripts from stages
    for entry in app.manifest:
        if entry.filtered or entry.failures:
            continue

        mfid = app.suite.manifest_id(entry)
        for stage in app.suite.stages():
            app.logger.debug(f"Running Stage(stage={stage.name}, manifest-id={mfid})")
            stage_dir = os.path.join(app.workdir, mfid, stage.name)
            ready_script = stage.script(entry)
            rcode = app.write_output(stage_dir, *app.exec_command(ready_script, shell=True))
            if rcode != 0:
                fmsg = f"Script failure(stage={stage}, exit={rcode}): {ready_script}"
                entry.failures.append(fmsg)
                app.logger.info(fmsg)

    # Create dump of unassociated files
    app.logger.debug("Generating report: unassociated.json")
    unassociated = []
    for fpath, _ in app.sourcedir.files(associated=False):
        unassociated.append(fpath.removeprefix(app.prefix))
    unassociated_path = os.path.join(app.workdir, 'unassociated.json')
    with open(unassociated_path, 'w') as unassociated_file:
        json.dump(unassociated, unassociated_file, indent=2)
        unassociated_file.write('\n')

    # TODO Create report of manifest
    #   - success, failure, skipped
    #   - count number of stages run on success
    #   - enumerate failures on failure
    #   - explain why skipped on skipped
    # TODO List count of unassociated after run
    #   - enumerate unassociated files

    # Save results as zip file
    with (
        tempfile.NamedTemporaryFile(prefix='colophon_', suffix='.zip', delete=False) as ztemp,
        zipfile.ZipFile(ztemp, 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zfile
    ):
        app.logger.debug(f"Bundling output into zip file: {ztemp.name}")
        for root, dirs, files in os.walk(app.workdir):
            for fname in files:
                filepath = os.path.join(root, fname)
                zfile.write(
                    filepath,
                    arcname=filepath.removeprefix(app.workdir).lstrip("/")
                )

        # Print out fullpath to zip file
        print(ztemp.name)

    # TODO Return/exit with 0 if no failures (if strict, only when no skips/unassociated also)
    return 0

if __name__ == "__main__":
    sys.exit(main())
