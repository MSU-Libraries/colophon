#!/usr/bin/env python3
import os
import sys
import tempfile
import logging
import json
import click
import jinja2
import app
# Add current path to sys path for loading libraries
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

@click.command()
@click.option('-m', '--manifest', required=True, type=str,
    help="The file manifest as csv file; first row defines labels for each column")
@click.option('-s', '--suite', required=True, type=str,
    help="The suite file defining files to match and what stages to run")
@click.option('-d', '--dir', 'sourcedir', required=True, type=str,
    help="The directory in which to find files defined by the suite and manifest")
@click.option('-w', '--workdir', type=str,
    help="A directory where to store temp files and results")
@click.option('-v', '--verbose', is_flag=True,
    help="Provide details output while running")
@click.option('-q', '--quiet', is_flag=True,
    help="Suppress output while running")
def main(manifest, suite, sourcedir, workdir, verbose, quiet):
    """Colophon - File Quality Control Validator"""
    # Manifest exists and is loadable
    app.manifest = app.Manifest(manifest)
    # Suite file exists and is loadable
    app.suite = app.Suite(suite)
    # Source dir exists and is readable
    app.sourcedir = app.Directory(sourcedir)

    # Create output dir if not provided
    if workdir is not None:
        app.workdir = os.path.abspath(workdir)
        check_wdir = app.Directory(app.workdir)
        if len(check_wdir) != 0:
            raise app.ColophonException(f"Work directory is not empty: {workdir}")
    else:
        app.workdir = tempfile.mkdtemp()

    # Configure logging
    logging.basicConfig(
        filename=os.path.join(app.workdir, 'colophon.log'),
        encoding='utf-8',
        level=logging.DEBUG
    )
    app.logger = logging.getLogger()

    # Populate results JSON with empty dict
    results_path = os.path.join(app.workdir, 'results.json')
    with open(results_path, 'w') as results_file:
        json.dump({}, results_file)
    app.globalctx['results_path'] = results_path

    # Pass manifest through suite to filter out rows
    for entry in app.manifest:
        entry.filtered = app.suite.filter(entry)

    # For each manifest row with all files found/associated, process the stages of suite
    for entry in app.manifest:
        if app.suite.label_files(entry):
            print(f"Failures found for {entry}")
            sys.exit(1) # TODO

    # For each manifest row, run scripts from stages
    for entry in app.manifest:
        if entry.filtered:
            continue

        for stage in app.suite.stages():
            stage_dir = os.path.join(app.workdir, stage.name)
            ready_script = stage.script(entry)
            app.logger.debug(f"Running script: {ready_script}")
            rcode, stdout, stderr = app.exec_command(ready_script, shell=True)
            app.logger.debug(f"Script exited with code: {rcode}")
            app.write_output(stage_dir, stdout, stderr)
            if rcode != 0:
                print(f"Script exited with code: {rcode}")
                sys.exit(1) # TODO

    # TODO Create report of successes

    # TODO Create report of failures

    # TODO Create report of unassociated files

    # TODO Save final state to disk
    return 0

if __name__ == "__main__":
    sys.exit(main())
