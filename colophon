#!/usr/bin/env python3
import os
import sys
import tempfile
import logging
import json
import zipfile
import click
import jinja2
import app
# Add current path to sys path for loading libraries
app.install_path = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, app.install_path)

CONTEXT_SETTINGS = {
    'help_option_names': ['-h', '--help']
}

@click.command(context_settings=CONTEXT_SETTINGS)
@click.option('-m', '--manifest', required=True, type=str, metavar='MNFST',
    help="The file manifest as CSV file; first row defines labels for each column")
@click.option('-s', '--suite', required=True, type=str, metavar='SUITE',
    help="The suite file defining files to match and what stages to run")
@click.option('-d', '--dir', 'sourcedir', required=True, type=str, metavar='DIR',
    help="The source directory in which to find files defined by the suite and manifest")
@click.option('-w', '--workdir', type=str, metavar='WORKDIR',
    help="A directory where to store temp files and results")
@click.option('-r', '--retry', type=str, metavar='FAILED',
    help="Re-run failed tests specified in provided JSON file from previous run")
@click.option('-t', '--strict', is_flag=True,
    help="Exit code 0 only with no manifest entries skipped and no unassociated files")
@click.option('-v', '--verbose', is_flag=True,
    help="Provide details output while running")
@click.option('-q', '--quiet', is_flag=True,
    help="Suppress output while running")
def main(manifest, suite, sourcedir, workdir, retry, strict, verbose, quiet):
    """Colophon - File Quality Control Validator"""
    # Create output dir if not provided
    if workdir is not None:
        app.workdir = os.path.abspath(workdir)
        if len(os.listdir(app.workdir)) != 0:
            raise app.ColophonException(f"Work directory must be empty: {workdir}")
    else:
        app.workdir = tempfile.mkdtemp()

    # Configure logging
    fileHandler = logging.FileHandler(os.path.join(app.workdir, 'colophon.log'))
    stderrHandler = logging.StreamHandler()
    stderrHandler.setLevel(
        logging.DEBUG if verbose else (logging.ERROR if quiet else logging.INFO)
    )
    logging.basicConfig(
        format="%(asctime)s [%(levelname)s] %(message)s",
        encoding='utf-8',
        level=logging.DEBUG,
        handlers=[fileHandler, stderrHandler]
    )
    app.logger = logging.getLogger()

    # Manifest exists and is loadable
    app.manifest = app.Manifest(manifest)
    # Suite file exists and is loadable
    app.suite = app.Suite(suite)
    # Source dir exists and is readable
    app.sourcedir = app.Directory(sourcedir)

    # Populate results JSON with empty dict
    results_path = os.path.join(app.workdir, 'results.json')
    with open(results_path, 'w') as results_file:
        json.dump({}, results_file)
    app.globalctx['results_path'] = results_path

    # TODO Retry failures from previous run

    # Pass manifest through suite to filter out rows to ignore
    app.logger.debug("Applying suite filter to manifest...")
    for entry in app.manifest:
        entry.filtered = app.suite.filter(entry)
    app.logger.debug(
        f"Manifest rows: selected={app.manifest.count()}, "
        f"filtered={app.manifest.count(True)}"
    )

    # For each manifest row, match/associate files to that row
    for entry in app.manifest:
        app.logger.debug(f"Labeling files for manifest row: {app.suite.manifest_id(entry)}")
        matched, failed = app.suite.label_files(entry)
        app.logger.debug(f"Files-found={matched}, failed-labels={failed}")
        if failed:
            fmsg = (
                f"Manifest(id={app.suite.manifest_id(entry)}) encountered "
                f"{failed} failures while creating file labels."
            )
            entry.failures.append(fmsg)
            app.logger.warning(fmsg)

    # For each manifest row, run scripts from stages
    for entry in app.manifest:
        if entry.filtered or entry.failures:
            continue

        mfid = app.suite.manifest_id(entry)
        for stage in app.suite.stages():
            app.logger.debug(f"Running Stage(stage={stage.name}, manifest-id={mfid})")
            stage_dir = os.path.join(app.workdir, mfid, stage.name)
            ready_script = stage.script(entry)
            rcode = app.write_output(stage_dir, *app.exec_command(ready_script, shell=True))
            if rcode == 16:
                fmsg = f"Script set entry as filtered (stage={stage}, exit={rcode}): {ready_script}"
                entry.filtered(fmsg)
                app.logger.info(fmsg)
            elif rcode != 0:
                fmsg = f"Script failure (stage={stage.name}, exit={rcode}): {ready_script}"
                entry.failures.append(fmsg)
                app.logger.info(fmsg)

    app.logger.debug("Generating final manifest CSV.")
    app.report.ManifestReport().generate()

    app.logger.debug("Generating summary JSON report.")
    summary = app.report.SummaryReport()
    summary.generate()

    # Save all output as zip file
    with (
        tempfile.NamedTemporaryFile(prefix='colophon_', suffix='.zip', delete=False) as ztemp,
        zipfile.ZipFile(ztemp, 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=9) as zfile
    ):
        app.logger.debug(f"Bundling output into zip file: {ztemp.name}")
        for root, dirs, files in os.walk(app.workdir):
            for fname in files:
                filepath = os.path.join(root, fname)
                zfile.write(
                    filepath,
                    arcname=filepath.removeprefix(app.workdir).lstrip("/")
                )

        # Print out fullpath to zip file
        print(ztemp.name)

    return summary.exit_code(strict)

if __name__ == "__main__":
    sys.exit(main())
