{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Colophon: File Quality Control Validator","text":"<p>Colophon is a tool to take a media object manifest, find related files using a flexible matching system, and then run any number of scripts to validate the files founds. The output is then bundled into a zip file, including HTML report summary, JSON data details, and full output of all scripts run.</p> <p>Table of Contents </p> <ul> <li>Installing</li> <li>How Colophon Works</li> <li>Running Colophon</li> <li>The Manifest File</li> <li>The Suite File</li> <li>Check Scripts</li> <li>Copyright and License</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>Colophon is written primarily in Python, but makes use of scripts to run validation tests. These scripts can be written in any language, and you can add your own quite easily!</p> <p>Create your virutal environment <pre><code># Using virtualenv here, but you can use whatever you want\nvirtualenv -p python3 env\n</code></pre></p> <p>Install Python dependences <pre><code># Activate your virtual environment\n. env/bin/activate\n# Install dependencies defined in the requirements.txt file\npip3 install -r requirements.txt\n</code></pre></p> <p>Running colophon <pre><code># If you've activated your environment\n./colophon -h\n# Or call via env directly\n./env/bin/python3 colophon -h\n</code></pre></p>"},{"location":"#script-dependencies","title":"Script Dependencies","text":"<p>Depending on which scripts you use, some of all of the following dependendies will be needed. Here are the commands to install them on Ubuntu, but you should be able to easily find these packages on most Linux distributions.</p> <p>Install dependencies on Ubuntu (<code>bash</code> already present) <pre><code>apt install -y jq imagemagick mediainfo\n</code></pre></p>"},{"location":"#what-is-needed-to-run","title":"What is Needed to Run","text":"<p>Before you can run Colophon, you will need the following:</p> <ul> <li>A folder with data to be checked (the files source directory)</li> <li>A CSV listing records that need to be verified (the manifest)</li> <li>A configuration file of what tests to run (the suite of tests)</li> </ul>"},{"location":"#other-terms-to-know","title":"Other Terms to Know","text":"<ul> <li>Error: A script was unable to complete. This is likely due to due incorrect input or missing dependencies.</li> <li>Failure: A script ran to completion, but the validation did not succeed on the given file using the given parameters.</li> </ul>"},{"location":"#how-colophon-works","title":"How Colophon Works","text":"<p>Colophon starts with the manifest file. This is an arbitrary CSV file with a header row to give column labels.</p> <pre><code>\"mediatype\",\"basename\", \"title\"\n\"Video\",    \"UP-F00001\",\"UPP302 - Press presentation 02/10/2004\"\n\"Video\",    \"UP-F00002\",\"UPP710 - President's speech 12/20/2007\"\n\"Book\",     \"UP-F00003\",\"UPP098 - College pamphlet 1921\"\n</code></pre> <p>When running Colphon, you will also specify a directory where files related to the manifest should be found.</p> <pre><code>batch_01/upp302/UP-F00001.mkv\nbatch_01/upp302/UP-F00001.mkv.md5\nbatch_01/upp302/UP-F00001.mp4\nbatch_01/upp302/UP-F00001.mp4.md5\nbatch_01/upp302/UP-F00001_asset_cover.tif\nbatch_01/upp302/UP-F00001_asset_back.tif\nbatch_01/upp710/UP-F00002.mkv\nbatch_01/upp302/UP-F00002.mkv.md5\nbatch_01/upp710/UP-F00002.mp4\nbatch_01/upp302/UP-F00002_digitization_notes.txt\nbatch_01/upp098/UP-F00003.pdf\nbatch_01/upp098/UP-F00003_front.tif\nbatch_01/upp098/UP-F00003_back.tif\nbatch_01/upp098/UP-F00003_front.jpg\nbatch_01/upp098/UP-F00003_back.jpg\n</code></pre> <p>And finally, a test suite file while specifies what Colophon should do.</p> <p>Example of the first part of a test suite file. The <code>manifest:</code> section: <pre><code>manifest:\nid: \"{{ basename }}\"  # id should be unique data; it's used in logs and output\nfilter:               # only use manifest rows that match these filters\n- value: mediatype\nequals: Video\nfiles:                # find files matching the manifest row\n- label: preserve_copy\nstartswith: \"{{ basename }}\"\nendswith: '.mkv'\n- label: access_copy\nstartswith: \"{{ basename }}\"\nendswith: '.mp4'\n- label: preserve_hash\nstartswith: \"{{ basename }}\"\nendswith: '.mkv.md5'\n- label: access_hash\nstartswith: \"{{ basename }}\"\nendswith: '.mp4.md5'\n- label: asset_file\nmultiple: true\noptional: true\nstartswith: \"{{ basename }}\"\nregex: '_asset.*\\.tif$'\n</code></pre></p> <p>Colophon will iterate over the rows in the manifest, comparing it to the suite and source directory. If manifest row matches the given suite files, Colophon will attempt to find matching files from the source directory based of definitions within the suite file.</p> <p>Example of the second part of a test suite file. The <code>stages:</code> section: <pre><code>stages:                 # run a set of stages (scripts) for each manifest row\naccess.hash:          # each stage name is just a label for identifing the stage\nscript: \"scripts/verify-hash -c {{ access_copy }} -f {{ access_hash }} -v -J {{ results_path }}\"\npreserve.hash:\nscript: \"scripts/verify-hash -c {{ preserve_copy }} -f {{ preserve_hash }} -v -J {{ results_path }}\"\naccess.audio:\nscript: \"scripts/validate-audio -c {{ access_copy }} -s 48000 -m CBR -v -J {{ results_path }}\"\npreserve.audio:\nscript: \"scripts/validate-audio -c {{ prezerve_copy }} -s 48000 -m CBR -b 24 -v -J {{ results_path }}\"\naccess.video:\nscript: \"scripts/validate-video -c {{ access_copy }} -d 640x480 -b 8 -v -J {{ results_path }}\"\npreserve.video:\nscript: \"scripts/validate-video -c {{ preserve_copy }} -d 720x486 -b 10 -v -J {{ results_path }}\"\n</code></pre></p> <p>With files in hand, Colophon then runs stages of user-defined scripts (also defined in the suite file). If those scripts succeed, then we move onto the next stage. Once all stages are completed for a manifest row, the process repeats for the next row until all rows are completed.</p> <p>Finally, all results, reports, and script output are bundled together and returned as a zip file.</p> <p>Example section of the <code>summary.json</code> file, which is included in the output: <pre><code>{\n\"row-overview\": {\n\"succeeded\": 1,\n\"failed\": 1,\n\"skipped\": 1\n},\n\"skipped\": [\"UP-F00003\"],\n\"failed\": [\"UP-F00002\"],\n\"unassociated-files\": [\n\"batch_01/upp302/UP-F00002_digitization_notes.txt\"\n],\n\"rows\": {\n\"UP-F00001\": {\n\"exit-codes\": {\n\"0\": {\n\"occurrences\": 6,\n\"code-meaning\": \"success\"\n}\n}\n},\n\"UP-F00002\": {\n\"failures\": [\n\"Manifest(id=UP-F00002) was required to match a file for label 'access_hash', but no matching file was found.\"\n]\n},\n\"UP-F00003\": {\n\"skipped-because\": \"Filter did not match: {'value': 'mediatype', 'equals': 'video'}\"\n}\n}\n}\n</code></pre></p> <p>Much of Colophon process is user defined, which makes it very flexible and configurable. It does mean you will need to invest some time into creating a the suite file before running your verifications.</p>"},{"location":"#running-colophon","title":"Running Colophon","text":"<p>Assuming you have the three required components ready (source directory, manifest file, suite file), then running <code>colophon</code> is quite simple. <pre><code>./colophon -m example_manifest.csv -s suites/verify-video.yml -d example_files/ -v\n</code></pre></p> <p>Where the arguments are:</p> <ul> <li><code>example_manifest.csv</code> is the CSV file containing the manifest</li> <li><code>suites/verify-video.yml</code> is a YAML file defining the suite to run against the manifest</li> <li><code>example_files/</code> is a directory where files associated with the manifest are located</li> </ul>"},{"location":"#flags-and-arguments","title":"Flags and Arguments","text":"<p>A full list of command options is also avilable by using the <code>-h</code> or <code>--help</code> flag.</p> <ul> <li><code>-m, --manifest MNFST</code>    The file manifest as csv file; first row defines labels for each column  [required]</li> <li><code>-s, --suite SUITE</code>       The suite file defining files to match and what stages to run  [required]</li> <li><code>-d, --dir DIR</code>           The source directory in which to find files defined by the suite and manifest  [required]</li> <li><code>-w, --workdir WORKDIR</code>   A directory where to store temp files and results</li> <li><code>-r, --retry FAILED</code>      Re-run failed tests specified in provided JSON file from previous run</li> <li><code>-i, --ignore-missing</code>    Ignore manifest entries that have no files matched</li> <li><code>-t, --strict</code>            Exit code 0 only with no manifest entries skipped and no unassociated files</li> <li><code>-v, --verbose</code>           Provide details output while running (verbose logs will always be inlcuded in output bundle)</li> <li><code>-q, --quiet</code>             Suppress output while running</li> </ul>"},{"location":"#colophon-exit-codes","title":"Colophon Exit Codes","text":"<p>The primary <code>colophon</code> script has three possible exit codes.</p> <ul> <li><code>0</code> There were no failures when running stages on manifest entries.</li> <li><code>1</code> An error occured. See output/logs for detals.</li> <li><code>2</code> While running stages, one or more failures occurred.</li> <li><code>2</code> (When using strict mode) A manifest entry was skipped or there were unassociated files.</li> </ul>"},{"location":"#colophon-output","title":"Colophon Output","text":"<p>If <code>colophon</code> exits without an error (exit code <code>0</code> or <code>2</code>), the only output to stdout will be the full path of of the results zip file. Any other output during a normal run will be to stderr.</p> <p>Should <code>colophon</code> exit with an error, no results zip file will be generated. All error messages will be send to stderr. You can also inspect files in the workdir for additional information. The workdir is where files are placed before getting added to the zip archive. The workdir is either manually specified with the <code>--workdir</code> flag or created automatically in a temp directory (e.g. in <code>/tmp/</code>).</p> <p>Details on what is contained within an output file are listed below.</p> <p><code>summary.json</code> A JSON file containing all manifest objects, including number of successful stages for each, failures and a short description for the failure reason, and explainations of why an manifest row was skipped. Additionally, if any files from the source directory did not matched any rows, they are listed as <code>unassociated-files</code> in the summary.</p> <p><code>results.json</code> A JSON files where scripts invoked by the stages can store additional output.</p> <p><code>manifest.csv</code> The processed manifest file, including any additional columns created from suite file matches.</p> <p><code>colophon.log</code> The verbose logs from the main <code>colophon</code> program.</p> <p><code>{ID}/{STAGE}/stdout.txt</code> For each stage/manifest row, the a file recording the stdout generated by script script.</p> <p><code>{ID}/{STAGE}/stderr.txt</code> For each stage/manifest row, the a file recording the stderr generated by script script.</p> <p><code>{ID}/{STAGE}/ecode.{EXITCODE}</code> For each stage/manifest row, the a file identifying the exit code from the script run. Human readable tags describing the exit code are within the file.</p>"},{"location":"#the-manifest-file","title":"The Manifest File","text":"<p>The manifest is a CSV file with fields relevant to performing the quality control checks desired. The can include:</p> <ul> <li>Sufficient naming to identify files</li> <li>Some identifying data, in the case where the name info doesn't do this</li> <li>The type of object or media, if multiple types are present</li> <li>Additional fields specifying validation parameters where they could vary from record to record</li> <li>E.g. Video resolution, color bit depth, compression type</li> </ul> <p>An example manifest could look like this: <pre><code>\"mediatype\",\"basename\",\"name\", \"resolution\", \"DPI\"\n\"audio\",\"MSUF000000\",\"Adams interview\", \"\", \"\"\n\"Video\",\"MSUF000001\",\"Billing's debate\", \"720x480\", \"\"\n\"book\",\"MSUF000002\",\"Chloe's Biography\", \"\", \"400\"\n\"Audio\",\"MSUF000003\",\"Declan's speech\", \"\", \"\"\n\"Video\",\"MSUF000005\",\"Eric's review\", \"640x480\", \"\"\n\"Book\",\"MSUF000006\",\"Ferrell's history \", \"\", \"300\"\n</code></pre></p> <p>If an attribute of a file is going to be consistent across all items being verified, they do not need to be in the manifest. We can put those values into the testing suite directly. </p>"},{"location":"#generating-a-manifest","title":"Generating a Manifest","text":"<p>If you have a spreadsheet, such as a <code>.xlsx</code> or <code>.ods</code> with the needed fields, Colophon comes with a helper script to convert it to <code>.csv</code>. It may be easier to create a new <code>.csv</code> using your preferred spreadsheet program, this script may help if you are trying to create a programmatic solutions.</p> <p>It takes a mapping of old column IDs (e.g. <code>a</code>, <code>b</code>, etc) to new column names, as well as number of header rows to ignore.</p> <p>Example manifest map <code>.yml</code> file: <pre><code>---\nskiprows: 1\ncolumns:\n- column: b\nlabel: mediatype\n- column: c\nlabel: basename\n- column: f\nlabel: name\n- column: j\nlabel: resolution\n- column: n\nlabel: dpi\n</code></pre></p> <p>Generating the manifest: <pre><code>./helpers/generate-manifest-from-spreadsheet -s my-speadsheet.xlsx -m my-mapfile.yml -o my-new-manifest.csv\n</code></pre></p>"},{"location":"#the-suite-file","title":"The Suite File","text":"<p>The suite file is written in Yaml and defines everything Colophon does when you run it. Example suite files are provided in the <code>suites/</code> directory with Colophon. You will need to heavily modify these to suite your own media if you decide to start with one of these.</p> <p>Basic structure of a suite files is as follows: <pre><code>---\n# The manifest: section defines how Colophon will read/update the manifest.\n# It operates on a row-by-row basis within the manifest. E.g. each row in the\n# manifest will be checked against the filter: and each row will search to\n# find matching files: from the source directory.\nmanifest:\n# The id: allows you to define how a manifest row is referred to by Colophon\n# A string value that should be unique (otherwise it would serve as a poor identifier!)\nid:       # (string)\n# The filter: allows you to selectively iterate over only manifest rows which\n# match all the filters you define here.\nfilter:   # (list)\n# The files: has you define rules for finding each of the files from the source\n# directory which will be associated with the manifest row. Each file has\n# a label you define and that label will be added to the manifest with the\n# associated value being the matched file(s).\nfiles:    # (list)\n\n# The stages: section defines a set of independent stages, each with a command\n# that will be run using the manifest row data. This happens only AFTER the\n# above manifest: section has completed filtering and finding files.\nstages:     # (associative array)\n</code></pre></p> <p>A full definition of manifest fields, templating values into them, and their sub-fields are covered in the next documentation sections.</p>"},{"location":"#template-strings","title":"Template Strings","text":"<p>Colophon makes use of Jinja2 template rendering when parsing values from suite files (except for <code>regex</code> expressons).</p> <p>Any fields within the manifest can be referenced inside the suite by means of Jinja expressions, such as <code>{{ field_name }}</code>. Depending on the context, additional variables may be available within the template render context.</p> <p>For example, if the manifest had a column header called <code>objectname</code>, then you would be able to reference <code>{{ objectname }}</code> within a string to insert the row value for that column.</p> <p>In addition to built-in Jina2 filters, Colophon provides the additional filters:</p> <ul> <li><code>basename</code> Runs Python's <code>os.path.basename()</code> on the value.</li> <li><code>esh</code> Escapes the value for use as a shell command argument. This is applied automatically within <code>stages:</code> section of suites.</li> </ul> <p><code>manifest.files:</code> Within the <code>files:</code> section, the following variables are available in addition to the normal <code>manifest</code> fields:</p> <ul> <li><code>file.name</code>: The full name of the file (no path)</li> <li><code>file.path</code>: The full path of the file</li> <li><code>file.base</code>: The name of the file without its extension</li> <li><code>file.ext</code>: The file extension (no leading period)</li> <li><code>file.size</code>: The size of the file in bytes</li> </ul> <p><code>stages</code> Within the <code>stages:</code> section, any files defined within the <code>manifest.files:</code> section have already been added to the manifest. The <code>label:</code> becomes the manifest field name, and the matched file becomes the value (or blank if not match and the file was optional).</p> <p>With stages, the variable <code>results_path</code> is also available. This is the path to the <code>results.json</code> which will be included in the output zip bundle. This is indended to be used with scripts' <code>-J</code> flag, which may output JSON results.</p> <p>Note: Jinja variables within the <code>stages</code> section of the manifest will be automatically quoted for use as arguments within a shell environment.</p>"},{"location":"#manifest-field-details","title":"Manifest Field Details","text":""},{"location":"#manifestid-string","title":"<code>manifest.id:</code> (string)","text":"<p>The <code>id:</code> field in the manifest is used within logs to identify which row the log entry is referring to. It is strongly recommended you define this to be a unique value from within your manifest.</p> <pre><code>manifest:\nid: \"{{ mediatype }}-{{ objectid }}\"\n</code></pre>"},{"location":"#manifestfilters-list","title":"<code>manifest.filters:</code> (list)","text":"<p>Allows the suite to filter specific rows to process. Only rows matching all provided filters will be used. Rows which do not match the filters will be ignored.</p> <p>Each filter is an associative array and takes a <code>value:</code>, which must be a manifest field name. Additionally, it needs one or more types of filters.</p> <p>The filter types are:</p> <ul> <li><code>equals:</code> The field in <code>value:</code> must be exactly the value of this.</li> <li><code>startswith:</code> The field in <code>value:</code> must start with the value of this.</li> <li><code>endswith:</code> The field in <code>value:</code> must end with the value of this.</li> <li><code>regex:</code> The field in <code>value:</code> must match this regular expression. (Note that <code>regex:</code> values do NOT render as Jinja2 templates.)</li> <li><code>ignorecase:</code> Boolean. If set to <code>true</code>, the other filter types within this filter are case insensitive. (Note that this does affect <code>regex:</code>.)</li> <li><code>greaterthan:</code> The field in <code>value:</code> must be numerically greater than this.</li> <li><code>lessthan:</code> The field in <code>value:</code> must be numerically less than this.</li> </ul> <pre><code>manifest:\nfilters:\n- value: mediatype\nequals: audio\nignorecase: true\n- value: donor\nendswith: Smith\n- value: year\ngreaterthan: 1950\nlessthan: 1961\n</code></pre>"},{"location":"#manifestfiles-list","title":"<code>manifest.files:</code> (list)","text":"<p>Define which files should be found for each row in the manifest. Each item in the <code>files:</code> section requires a <code>label:</code> defined. The <code>label:</code> will be a new field within the manifest for which the value will be the path of the matched file(s).</p> <p>Each entry in <code>files:</code> also makes use of the same filter types defined in the <code>manifest.filters:</code> section above.</p> <p>Additionally, the following fields are available:</p> <ul> <li><code>multiple:</code> Boolean. If set to <code>true</code>, this file entry can match any number of files.</li> <li><code>optional:</code> Boolean. If set to <code>true</code>, this file entry is optional and will not cause a failure should no matching files be found.</li> <li><code>linkedto:</code> Defines a linked file. Must be given <code>label:</code> to another file that has already been defined. This requires a file match for each file match the linked file entry finds, even if that linked file entry was optional.</li> </ul> <pre><code>manifest:\nfiles:\n- label: metadata_file\nstartswith: \"{{ objectname }}\"\nendswith: '_mods.xml'\n- label: pres_file\nstartswith: \"{{ objectname }}\"\nregex: '(?:\\.mov|\\.mkv)$'\n- label: pres_hash\nstartswith: \"{{ objectname }}\"\nregex: '(?:\\.mov|\\.mkv).md5$'\n- label: asset\nmultiple: true\noptional: true\nstartswith: \"{{ objectname }}\"\nendswith: '_asset.tif'\n- label: asset_hash\nlinkedto: asset\nstartswith: \"{{ asset | basename }}\"\nendswith: '.md5'\n</code></pre>"},{"location":"#stages-associative-array","title":"<code>stages:</code> (associative array)","text":"<p>The <code>stages:</code> section contains any number of stages which will be iterated over in order.</p>"},{"location":"#stagesstage_name-associative-array","title":"<code>stages.STAGE_NAME:</code> (associative array)","text":"<p>Where <code>STAGE_NAME</code> is a unique value used to identify that stage. For example, it could be <code>stage1.0</code>, <code>stage1.1</code>, <code>stage1.2</code>, etc. Or more descriptive like <code>audio.file-metadata</code>,<code>audio.waveform</code>,<code>video-metadata</code>, etc.</p> <p>The <code>STAGE_NAME</code> will be used within logs and in structuring the location of script output files (e.g. <code>stdout.txt</code>).</p>"},{"location":"#stagesstage_namescript-string","title":"<code>stages.STAGE_NAME.script:</code> (string)","text":"<p>Define the script command to run for the given stage. Jinja expressions used within the command will be auto-escaped for use as arguments within a shell command.</p> <p>The output of the command will always be saved in the output zip bundle within the path <code>{{ manifest.id }}/{{ STAGE_NAME }}/</code>:</p> <ul> <li><code>stdout.txt</code> All output to stdout while the script ran.</li> <li><code>stderr.txt</code> All output to stderr while the script ran.</li> <li><code>ecode.?</code> The script exit code (where <code>?</code> is in the filename). The contents of the file will also include the exit code and human readable label(s) explaining the exit code's meaning.</li> </ul> <pre><code>stages:\nvideo.hash:\nscript: \"scripts/verify-hash -c {{ media_file }} -f {{ media_file_hash }} -v -J {{ results_path }}\"\nvideo.size:\nscript: \"custom-scripts/validate-size -c {{ media_file }} --min-size {{ bytes_lower }} --max-size {{ bytes_upper }} -v\"\n</code></pre>"},{"location":"#check-scripts","title":"Check Scripts","text":"<p>Colophon works by running a set of check scripts in stages against your manifest.</p> <p>Well written scripts will provide a full list of flags and their use by using the <code>-h</code> or <code>--help</code> flag. <pre><code>$ ./scripts/verify-hash -h\n\nUsage: verify-hash [FLAGS]\n\nVerify a file contents matches a given hash\n\nFLAGS:\n  -c|--check-file FILE\n      The file to verify\n  -f|--hash-file HASH_FILE\n      A file containing a hash to verify against.\n  -s|--hash-str HASH_STR\n      A string hash to verify against.\n  -a|--algo ALGO\n      The algorithm to use. E.g. md5, sha1, sha256, etc\n  -J|--json JSON\n      Write results to the file JSON.\n  -v|--verbose\n      Display verbose output.\n</code></pre></p>"},{"location":"#included-check-scripts","title":"Included Check Scripts","text":"<p>Colophon includes a number of check-scripts, though you can always write your own. Additional scripts and script features will be included with each future Colophon release.</p> <p>All these are included in the <code>scripts/</code> directory. A brief summary of these scripts are included below. For the most up-to-date info on these scripts, refer to their <code>--help</code> info.</p>"},{"location":"#verify-hash","title":"<code>verify-hash</code>","text":"<p>Verify a file contents matches a given hash, the hash being either in a file or passed as string argument.</p> <p>Example use: <pre><code># Verify MD5 hash of media-file.wav matches hash within media-file.wav.md5 (algo auto-detected)\n./scripts/verify-hash -c media-file.wav -f media-file.wav.md5 -v\n# Verify MD5 hash of media-file.wav matches hash within media-file.wav.md5 (hash file auto-detected)\n./scripts/verify-hash -c media-file.wav -a md5 -v\n# Verify MD5 hash of media-file.wav matched provided string hash\n./scripts/verify-hash -c media-file.wav -s d8e8fca2dc0f896fd7cb4cb0031ba249 -v\n</code></pre></p>"},{"location":"#validate-image","title":"<code>validate-image</code>","text":"<p>Validate the given image has the attributes provided. If multiple values for the same attribute is given, the image may match any one of them.</p> <p>Example use: <pre><code># Validate image dimension either of the provided options and that compression is disabled\n./scripts/validate-image -c media-file.tif -d 4000x3000 -d 6000x3000 -x none -v\n# Validate image dimension is exactly the provided one and that compression is LZW\n./scripts/validate-image -c media-file.tif -d 1600x1200 -x lzw -v\n</code></pre></p>"},{"location":"#validate-audio","title":"<code>validate-audio</code>","text":"<p>Validate the given audio file, or an audio stream in a video file, has the attributes provided. If multiple values for the same attribute is given, the media file may match any one of them.</p> <p>Example use: <pre><code># Validate audio stream sampling rate (either 44100 or 48000), bitrate mode (CBR), and bit depth (24)\n./scripts/validate-audio -c media-file.wav -s 48000 -s 44100 -m cbr -b 24 -v\n</code></pre></p>"},{"location":"#validate-video","title":"<code>validate-video</code>","text":"<p>Validate the given video file has the attributes provided. If multiple values for the same attribute is given, the media file may match any one of them.</p> <p>Example use: <pre><code># Validate video stream dimensions (either 720x486 or 720x480) and color bit depth (10)\n./scripts/validate-video -c media-file.mkv -d 720x486 -d 720x480 -b 10 -v\n</code></pre></p>"},{"location":"#writing-a-check-script","title":"Writing a Check Script","text":"<p>A check script can be written in any lanugage or shell which abides by a set of rules.</p>"},{"location":"#relative-paths","title":"Relative Paths","text":"<p>Check scripts should accept relative paths as input arguments and should NOT attempt to convert them into absolute paths at any point. If relative paths were passed in, then relative paths should be used for any logs or output.</p>"},{"location":"#input","title":"Input","text":"<p>It is recommended that a check script can accept a JSON file as an input argument. This would be the <code>results.json</code> and the script should write the result of its check to this file in a manner that does not overwrite any other data in the file (additions only).</p> <p>The choice for how you accept input arguments for the script is up to you, but it is recommended to follow the same style as existing scripts. Have a look at the <code>scripts/</code> directory for examples.</p>"},{"location":"#file-modification","title":"File Modification","text":"<ol> <li>A script must never modify any data or file from the source directory.</li> <li>A script must never create any files/folders inside the source directory.</li> </ol>"},{"location":"#output","title":"Output","text":"<p>Output from a check script may write anything to stdout or stderr, be it output from commands it is calling, debug messages, or informational messages.</p> <p>A check script should write failures or warning information to stderr instead of stdout. This will be logged separately in order to help assist with reviewing and media issues found.</p> <p>A check script may write structured output data into the Results-JSON file.</p>"},{"location":"#exit-codes","title":"Exit Codes","text":"<p>Check scripts must have a standard exit code which indicates the result of the script. A code of <code>0</code> means the check was successful. Any other value means something occurred which might require attention; this includes failing the check entirely, but may also be something like a warning notice. In call cases where a non-<code>0</code> exit code was generated, you can refer to the script output for details.</p> <p>Exit Codes</p> <ul> <li><code>0</code>  indicates that the script ran successfully and no issues were found.</li> <li><code>1</code>  indicates that the check failed for some reason. See output/logs.</li> <li><code>3</code>  indicates that the file(s) used as part of the check were missing or unreadable.</li> <li><code>5</code>  indicates that the parameters passed to the script were incomplete or invalid.</li> <li><code>9</code>  indicates that the script ran, but warning messages were generated.</li> <li><code>16</code> indicates that the check did NOT fail, but the manifest row should be marked as ignored.</li> </ul> <p>When creating a check script at its simplest form, a script that returns either <code>0</code> or <code>1</code> will suffice.</p> <p>Note the special value <code>16</code> allows a script to stop a row from being futher processed. Essentially, this can be leveraged to do the same thing as a <code>filter:</code> would (ignoring the manifest row), only from within the <code>stages:</code> section.</p> <p>Exit code can be broken down into binary representation, each bit indicated a state. Each state has a descriptive string associated with it. Numerical values may be added up to represent the desired status. (E.g. <code>25</code> would indicate <code>16</code> + <code>8</code> + <code>1</code>)</p> Number (Bit) Descriptive message Meaning 128 (7) N/A Bit reserved for future use 64 (6) N/A Bit reserved for future use 32 (5) N/A Bit reserved for future use 16 (4) <code>skip_manfest_row</code> Script indicated this manifest row should be skipped in all further processing 8 (3) <code>warning_logged</code> One or more warning was generated by the script 4 (2) <code>bad_argument</code> One or more script arguments were incorrect or misused 2 (1) <code>inaccessible_file</code> One or more files were missing or inaccessible 1 (0) <code>failure</code> Script encountered failure 0 (if unset) <code>success</code> Script ran without a failure"},{"location":"#results-json-file-as-input-argument","title":"Results JSON File as Input Argument","text":"<p>It is recommended that scripts accept a JSON file as an argument (using the <code>-J</code> flag is preferred). The scripts may then output structured results by creating/updating the JSON file.</p> <p>If the given results JSON file already exist, the script should add data to it. If the JSON file does not exist, then the script must create the file itself.</p> <p>In dealing with the results JSON files, the script should:</p> <ul> <li>Never overwrite other data already in and existing JSON file.</li> <li>Attempt to write data in a way where collisions would never occur; e.g. appending to a list.</li> <li>Separate results generated using the check script from other results in the file.</li> <li>Preferably, output should be written under a key that matches the script's filename.</li> </ul> <p>Writing to the results file in the following manner is recommended: <pre><code>{\n  \"my-check-script\": [\n    {\n      \"file\": \"/path/to/fileA.txt\",\n      \"outcome\": \"acceptable\"\n    },\n    {\n      \"file\": \"/path/to/fileB.txt\",\n      \"outcome\": \"unacceptable\"\n    }\n  ]\n}\n</code></pre> However, writing to the results file in this next manner is discouraged: <pre><code>{\n  \"/path/to/fileA.txt\": [\n    {\n      \"script\": \"my-check-script\",\n      \"outcome\": \"acceptable\"\n    }\n  ],\n  \"/path/to/fileB.txt\": [\n    {\n      \"script\": \"my-check-script\",\n      \"outcome\": \"unacceptable\"\n    }\n  ]\n}\n</code></pre></p> <p>This second bad example of output fails to separate the script output from other types of output. If two scripts did the same practice, then both differing output types would be mixed in the same list format! This would be very annoying to try to parse.</p>"},{"location":"#author-and-copyright","title":"Author and Copyright","text":"<p>Written by Nathan Collins (npcollins/gmail/com)  </p> <p>Copyright \u00a9 2021 Michigan State University Board of Trustees  </p>"},{"location":"#license","title":"License","text":"<p>Released under the MIT License</p>"}]}